# 为什么选择 AgentFense?

## TL;DR

**产品定位**: 一个基于文件系统的沙盒,为 AI Agent 和自动化任务提供路径级最小权限控制,让它们可以在真实代码库上执行 bash 命令,同时不会暴露敏感数据。

**核心价值**: 在生产代码库上运行不可信代码,并实施文件系统级访问控制——Agent 可以自然地使用 bash/grep/find,但 `.env` 在它眼里根本不存在,而不仅仅是"禁止访问"。

**适用场景**: 当你需要授予自动化任务(AI Agent、CI 脚本、第三方工具)精确的文件系统访问权限时——不是"读取整个仓库"或"完全不挂载",而是"可读 docs/,可写 output/,secrets 不存在"。

---

## 问题:文件系统访问是"全有或全无"

### 开发者今天面临的困境

当你需要在真实代码库上运行自动化任务时,会面临一个无解的选择:

**方案 1:挂载整个仓库**
```bash
docker run -v $(pwd):/workspace my-agent
# ❌ 暴露 .env、.key 文件、customer_data/ 等所有内容
# ❌ Agent 可以读取密钥、覆盖关键文件
# ❌ 无法审计实际访问了什么
```

**方案 2:完全不挂载,使用基于 API 的文件访问**
```python
# Agent 请求:"读取文件 X"
content = api.read_file(path)
# ❌ 丧失 bash 生产力(无法用 ls、grep、find)
# ❌ API 调用量 10 倍增加,速度慢 10 倍
# ❌ Agent 无法使用熟悉的 shell 命令
```

**方案 3:复制文件进出**
```bash
cp safe_files/ /tmp/sandbox/
docker run /tmp/sandbox agent-command
cp /tmp/sandbox/output/ ./results/
# ❌ 源文件变化后数据陈旧
# ❌ 存储开销(复制每个文件)
# ❌ 无法处理大型仓库(100GB+ 代码库)
```

### 真实成本

让我们量化这些问题给团队带来的实际成本:

| 痛点 | 传统方案 | 成本 |
|------|---------|------|
| **安全事件** | 挂载整个仓库,Agent 将 `.env` 泄露到日志 | 1 个密钥泄露 = 事件响应(数小时) + 轮换(所有服务) + 事后分析 |
| **开发速度** | 基于 API 的文件访问 → 10 倍往返次数 | 30 秒任务变成 5 分钟;每天 100 个任务 = 每周浪费 8 小时 |
| **合规审计** | 无法查看 Agent 访问了什么 | 每次 Agent 运行都需手动代码审查;无法通过审计要求 |
| **多租户隔离** | 每用户/任务运行独立容器 | 10GB × 100 用户 = 1TB 浪费;50 个并发用户时崩溃 |
| **维护负担** | 每个 Agent 脚本中实现自定义权限逻辑 | 200 行"检查路径是否是密钥"代码 × 15 个脚本 = 3000 行待维护代码 |

**具体案例**:一个在 monorepo 上运行代码审查的典型 LLM Agent:
- 没有路径级控制:读取 10,000 个文件包括 `.env` → 在上下文中泄露 API 密钥 → 凭证轮换 + 停机
- 使用 AgentFense:只能看到 `/src`、`/tests`(15% 文件) → 完成审查 → 零密钥暴露

---

## 为什么重要:从"能运行"到"可控制"

传统沙盒解决**隔离**问题(安全运行不可信代码)。AgentFense 解决**最小权限**问题(控制隔离代码能看到什么)。

### 核心转变:文件系统级访问控制

不再是"给 Agent 容器的读取权限",而是定义:

```python
permissions = [
    {"pattern": "**/*", "permission": "read"},        # 默认:读取所有
    {"pattern": "/docs/**", "permission": "write"},   # 可修改文档
    {"pattern": "/secrets/**", "permission": "none"}, # 完全不可见
]
```

**这带来什么能力**:

1. **密钥不可见,而不仅是"被阻止"**
   - `ls /workspace` → `.env` 不会出现
   - `cat .env` → "No such file"(不是"Permission denied")
   - Agent 甚至不知道密钥存在 → 无法通过提示注入绕过限制

2. **可见性控制(`view` 级别)**
   - Agent 可以看到 `/metadata/schema.json` 存在(用于文档)
   - 但无法读取其内容(防止数据泄露)
   - 适用场景:列出可用配置而不暴露配置值

3. **路径级写入边界**
   - Agent 只能写入 `/output`、`/tmp`
   - 无法意外执行 `rm -rf /src`
   - Agent 崩溃时自动回滚

4. **多沙盒共享代码库(Delta Layer)**
   - 100 个沙盒共享 1 个代码库(10GB) → 10GB + 100×5MB = 10.5GB 总计
   - 每个沙盒的写入通过 Copy-On-Write 隔离
   - 并发任务间零交叉污染

---

## 价值:安全性 + 效率 + 可审计性

### 1. 安全性:从设计上防止泄露

**问题**: AI Agent 通常会记录它们看到的所有内容。如果看到 `.env`,就会泄露。

**解决方案**: 让密钥**不可见**(而不仅是"被禁止")。

```python
# 传统挂载:Agent 可以读取 .env
result = agent.run("find . -name '*.env'")
# → 找到 .env → 读取它 → 记录它 → 泄露

# AgentFense:.env 在 Agent 的现实中不存在
result = sandbox.run("find . -name '*.env'")  
# → 找不到任何文件 → 无法泄露它看不见的东西
```

**可量化影响**:
- **零密钥暴露**: `none` 权限的路径无法在 `ls`、`find` 或任何系统调用中出现
- **审计面减少 90%**: 如果 Agent 只能看到 10% 的文件,你只需审计 10% 的访问
- **满足合规要求**: 每次文件访问都记录权限检查结果

### 2. 效率:Bash 生产力而无 API 开销

**问题**: 基于 API 的文件访问比文件系统操作慢 10 倍。

**解决方案**: Agent 使用原生 bash——文件系统透明地执行权限控制。

```python
# 基于 API:每个文件操作都是网络调用
for file in files:
    content = api.read(file)  # 每次调用 50ms
    process(content)
# 1000 个文件 × 50ms = 50 秒

# AgentFense:Agent 直接运行 bash
sandbox.run("grep -r 'TODO' /workspace/src")  
# → 原生 grep 速度 → 1000 个文件用 2 秒
```

**可量化影响**:
- 批量操作**快 25 倍**(grep、find、wc)
- **零学习曲线**: Agent 已经懂 bash/ls/cat
- **更低 token 成本**: 无需解释"用 API 调用访问文件"

### 3. 成本:多租户无需多容器

**问题**: 为 100 个用户运行 100 个 Docker 容器 → 1TB 内存,规模化时崩溃。

**解决方案**: 100 个沙盒通过 Delta Layer(COW)共享 1 个代码库。

| 方案 | 存储 | 内存 | 最大并发 |
|------|------|------|----------|
| 每用户一个 Docker | 10GB × 100 = 1TB | 512MB × 100 = 50GB | 20-30(OOM 崩溃) |
| AgentFense + Delta | 10GB + 100×5MB = 10.5GB | 8MB × 100 = 800MB | 200+(已测试) |

**可量化影响**:
- **存储减少 95%**(10.5GB vs 1TB)
- **内存减少 98%**(800MB vs 50GB)
- **并发能力增加 10 倍**(200 vs 20)

### 4. 可审计性:知道访问了什么

**问题**: 无法查看"Agent 是否接触了敏感文件?"

**解决方案**: 每个文件操作都记录权限检查。

```
[INFO] Sandbox sb_123: Read allowed: /docs/README.md
[WARN] Sandbox sb_123: Write denied: /src/auth.py (permission: read)
[INFO] Sandbox sb_123: Path invisible: /secrets/.env (permission: none)
```

**可量化影响**:
- **完整审计轨迹**: 每次访问都记录(允许或拒绝)
- **支持取证**: 事件后重放"Agent X 看到了什么?"
- **合规证明**: 导出日志证明密钥从未可访问

---

## 什么时候你必须使用 AgentFense

检查这些条件——如果满足 3+ 项,AgentFense 是正确的工具:

- [ ] **运行不可信或半可信代码**(AI Agent、第三方插件、外部贡献者的 CI 任务)
- [ ] **代码库包含密钥**(`.env`、`*.key`、`credentials.json`、客户数据)必须永不暴露
- [ ] **需要路径级粒度**(不是"读整个仓库"或"什么都不读")——例如"读 docs/,写 output/,密钥不可见"
- [ ] **Agent 必须使用 bash/shell 命令**(不只是 API 调用)——为了性能、熟悉度或复杂操作(grep/find/awk)
- [ ] **多用户或多任务并发**(SaaS 平台、并行 CI/CD 任务、Agent 集群)——无法承担每任务一个容器
- [ ] **合规/审计要求**(SOC2、HIPAA、PCI-DSS)——需要证明密钥从未可访问,不仅是"我们告诉 Agent 不要读"
- [ ] **故障安全隔离**(即使 Agent 被入侵/提示注入,也无法逃逸权限)
- [ ] **构建平台**(不是一次性脚本)——需要可复用、声明式的权限模型

**如果满足 3+ 项**: AgentFense 提供的权限系统,你无法在数月的 FUSE/内核/安全工程投入下自行构建。

**如果满足 6+ 项**: 你处于 AgentFense 的最佳适用场景——文件系统级最小权限是你唯一可扩展的路径。

---

## AgentFense 的独特之处

### 不只是"又一个沙盒"

| 维度 | 传统沙盒 | AgentFense |
|------|---------|------------|
| **粒度** | 容器/VM 级隔离 | 路径级权限 |
| **可见性** | 所有文件可见(阻止读取) | `none` = 不可见(零知识) |
| **思路** | "Agent 能看到所有,我们阻止访问" | "Agent 的现实被限制在允许的路径" |
| **可审计性** | 记录 Agent 命令(猜测它访问了什么) | 记录每个文件操作(知道访问了什么) |
| **多租户** | 每用户 1 容器(昂贵) | 1 代码库 + N 沙盒(便宜) |

### 关注**机制**,而非**策略**

AgentFense 不会告诉你"Agent 不应看到密钥"(你已经知道了)。它为你提供**在内核级执行它的机制**,因此即使被入侵/越狱的 Agent 也无法绕过限制。

**策略**(你想要什么):
> "这个 Agent 可以读文档、写日志,但密钥应该隐藏。"

**机制**(AgentFense 如何执行):
> FUSE 文件系统拦截每个 `open()`、`readdir()`、`stat()` 系统调用 → 检查权限规则 → 对 `none` 返回 ENOENT,对违规返回 EACCES → 密钥在 Agent 的命名空间中根本不存在。

你获得**纵深防御**: 即使 Agent 是恶意的,它也无法逃脱文件系统边界。

---

## 下一步

- **5 分钟试用**: [快速开始](../quickstart.md)
- **查看真实场景**: [使用场景](./use-cases.md)
- **对比方案**: [AgentFense vs. 其他方案](./comparison.md)
- **理解工作原理**: [架构概览](./architecture.md)
